clear; clc; close all;

[files, path] = uigetfile('mat/comparison/*.mat', 'MultiSelect', 'on');
if isequal(files, 0), error('No file'); end
if ischar(files), files = {files}; end  % tek dosya seçildiyse

fprintf('=== %d dosya seçildi ===\n\n', length(files));

for f = 1:length(files)
    load(fullfile(path, files{f}));
    fprintf('\n========== τ=%.1f (%d/%d) ==========\n\n', tau, f, length(files));
    
    SNR_range = 0:2:14;
    n_snr = length(SNR_range);
    
    ber = zeros(7, n_snr);
    ber_uncoded = zeros(1, n_snr);
    ber_theory = qfunc(sqrt(2 * 10.^(SNR_range/10)));
    
    min_err = 20;
    max_bits = 1e6;
    
    models = {net1, net2, net3, net4, net5, net6, net7};
    names = {'Single', 'Single+DF', 'Neighbors', 'Neighbors+DF', 'Window', 'Window+DF', 'Full'};
    params = {
        {1, 0, 0, false};
        {1, num_feedback, 0, false};
        {1, 0, num_neighbor, true};
        {1, num_feedback, num_neighbor, true};
        {window_len, 0, 0, false};
        {window_len, num_feedback, 0, false};
        {window_len, num_feedback, num_neighbor, false};
    };
    
    for m = 1:7
        fprintf('Model %d: %s\n', m, names{m});
        p = params{m};
        for s = 1:n_snr
            [err, total] = test_model(models{m}, tau, SNR_range(s), ...
                p{1}, p{2}, p{3}, p{4}, min_err, max_bits);
            ber(m, s) = err / total;
            fprintf('  %2d dB: %.2e\n', SNR_range(s), ber(m, s));
        end
    end
    
    fprintf('\nUncoded FTN\n');
    for s = 1:n_snr
        [err, total] = test_uncoded(tau, SNR_range(s), min_err, max_bits);
        ber_uncoded(s) = err / total;
        fprintf('  %2d dB: %.2e\n', SNR_range(s), ber_uncoded(s));
    end
    
    % Plot
    figure('Position', [100 + f*30, 100, 1000, 600]);
    colors = {'c', 'c', 'm', 'm', 'b', 'g', 'k'};
    markers = {'x', 'o', 'x', 'o', 's', 's', 'p'};
    lines = {'-', '--', '-', '--', '-', '-', '-'};
    linewidths = [1.5, 1.5, 1.5, 2, 1.5, 2, 2.5];
    
    semilogy(SNR_range, ber_theory, 'k--', 'LineWidth', 2, 'DisplayName', 'AWGN Theory');
    hold on;
    semilogy(SNR_range, ber_uncoded, 'r-^', 'LineWidth', 1.5, 'DisplayName', 'Uncoded FTN');
    
    for m = 1:7
        semilogy(SNR_range, ber(m,:), [colors{m} lines{m} markers{m}], ...
            'LineWidth', linewidths(m), 'MarkerSize', 7, 'DisplayName', names{m});
    end
    
    grid on;
    xlabel('E_b/N_0 (dB)', 'FontSize', 12);
    ylabel('BER', 'FontSize', 12);
    legend('Location', 'southwest', 'FontSize', 9);
    title(sprintf('FTN Detection (τ = %.1f)', tau), 'FontSize', 13);
    ylim([1e-6 0.5]);
    
    % Save
    save(fullfile(path, strrep(files{f}, '.mat', '_results.mat')), ...
        'SNR_range', 'ber', 'ber_uncoded', 'ber_theory', 'names', 'tau');
end

fprintf('\n=== Tamamlandı ===\n');

%% Functions (aynı kalıyor)
function [errors, total] = test_model(net, tau, SNR_dB, win_len, num_fb, num_nb, neighbors_only, min_err, max_bits)
    sps = 10; span = 6;
    h = rcosdesign(0.3, span, sps, 'sqrt');
    h = h / norm(h);
    
    step = round(sps * tau);
    delay = span * sps;
    half_win = floor(win_len / 2);
    
    errors = 0;
    total = 0;
    
    while errors < min_err && total < max_bits
        N = 50000;
        bits = randi([0 1], N, 1);
        symbols = 2 * bits - 1;
        
        tx = conv(upsample(symbols, step), h);
        noise_var = 1 / (2 * 10^(SNR_dB/10));
        rx = tx + sqrt(noise_var) * randn(size(tx));
        rx = conv(rx, h);
        rx = rx / std(rx);
        
        df_history = zeros(num_fb, 1);
        start_idx = max([num_fb + 1, num_nb + 1, 1]);
        
        if num_fb > 0
            for i = start_idx:N
                center = (i - 1) * step + 1 + delay;
                if center - half_win < 1 || center + half_win > length(rx), continue; end
                if num_nb > 0 && (center - num_nb*step < 1 || center + num_nb*step > length(rx)), continue; end
                
                feat = build_features(rx, center, half_win, win_len, step, num_nb, df_history, neighbors_only);
                
                probs = predict(net, feat);
                [~, pred_class] = max(probs);
                pred_bit = pred_class - 1;
                pred_sym = 2 * pred_bit - 1;
                
                if pred_bit ~= bits(i), errors = errors + 1; end
                total = total + 1;
                
                df_history = [pred_sym; df_history(1:end-1)];
                
                if errors >= min_err || total >= max_bits, return; end
            end
        else
            feat_buf = [];
            bit_buf = [];
            
            for i = start_idx:N
                center = (i - 1) * step + 1 + delay;
                if center - half_win < 1 || center + half_win > length(rx), continue; end
                if num_nb > 0 && (center - num_nb*step < 1 || center + num_nb*step > length(rx)), continue; end
                
                feat = build_features(rx, center, half_win, win_len, step, num_nb, [], neighbors_only);
                feat_buf = [feat_buf; feat];
                bit_buf = [bit_buf; bits(i)];
                
                if size(feat_buf, 1) >= 1000 || i == N
                    probs = predict(net, feat_buf);
                    [~, pred_classes] = max(probs, [], 2);
                    pred_bits = pred_classes - 1;
                    
                    errors = errors + sum(pred_bits ~= bit_buf);
                    total = total + length(bit_buf);
                    
                    if errors >= min_err || total >= max_bits, return; end
                    
                    feat_buf = [];
                    bit_buf = [];
                end
            end
        end
    end
end

function feat = build_features(rx, center, half_win, win_len, step, num_nb, df_history, neighbors_only)
    if neighbors_only
        win_feat = zeros(1, 1 + 2*num_nb);
        win_feat(1) = rx(center);
        for k = 1:num_nb
            win_feat(1 + k) = rx(center - k*step);
            win_feat(1 + num_nb + k) = rx(center + k*step);
        end
        nb_feat = [];
    else
        if win_len == 1
            win_feat = rx(center);
        else
            win_feat = rx(center - half_win : center + half_win)';
        end
        
        if num_nb > 0
            nb_feat = zeros(1, 2 * num_nb);
            for k = 1:num_nb
                nb_feat(k) = rx(center - k * step);
                nb_feat(num_nb + k) = rx(center + k * step);
            end
        else
            nb_feat = [];
        end
    end
    
    if ~isempty(df_history)
        df_feat = df_history';
    else
        df_feat = [];
    end
    
    feat = [win_feat, nb_feat, df_feat];
end

function [errors, total] = test_uncoded(tau, SNR_dB, min_err, max_bits)
    sps = 10; span = 6;
    h = rcosdesign(0.3, span, sps, 'sqrt');
    h = h / norm(h);
    
    step = round(sps * tau);
    delay = span * sps;
    
    errors = 0;
    total = 0;
    
    while errors < min_err && total < max_bits
        N = 50000;
        bits = randi([0 1], N, 1);
        symbols = 2 * bits - 1;
        
        tx = conv(upsample(symbols, step), h);
        noise_var = 1 / (2 * 10^(SNR_dB/10));
        rx = tx + sqrt(noise_var) * randn(size(tx));
        rx = conv(rx, h);
        
        for i = 1:N
            idx = (i - 1) * step + 1 + delay;
            if idx < 1 || idx > length(rx), continue; end
            
            pred_bit = real(rx(idx)) > 0;
            if pred_bit ~= bits(i), errors = errors + 1; end
            total = total + 1;
            
            if errors >= min_err || total >= max_bits, return; end
        end
    end
end